"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WcSdk = exports.WcSdkError = exports.DEFAULT_AUTO_ACCEPT_METHODS = exports.SUPPORTED_NETWORKS = exports.DEFAULT_BLOCKCHAIN = exports.SUPPORTED_BLOCKCHAINS = exports.COMPATIBILITY_VERSION = void 0;
const sign_client_1 = __importDefault(require("@walletconnect/sign-client"));
const events_1 = __importDefault(require("events"));
const defaultMethodRemovedWarning = 'The default value of methods has been deprecated, in future versions you will need to pass a list of method names';
exports.COMPATIBILITY_VERSION = 3;
exports.SUPPORTED_BLOCKCHAINS = ['neo3'];
exports.DEFAULT_BLOCKCHAIN = 'neo3';
exports.SUPPORTED_NETWORKS = ['neo3:private', 'neo3:testnet', 'neo3:mainnet'];
exports.DEFAULT_AUTO_ACCEPT_METHODS = [
    'testInvoke',
    'getWalletInfo',
    'traverseIterator',
    'getNetworkVersion',
    'calculateFee',
    'wipeRequests',
];
class WcSdkError extends Error {
    constructor(payload) {
        super();
        this.payload = payload;
    }
}
exports.WcSdkError = WcSdkError;
class WcSdk {
    sendRequest(method, params) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                id: 1,
                jsonrpc: '2.0',
                method,
                params: Object.assign(Object.assign({}, params), { contextualMessage: this.contextualMessage }),
            };
            delete this.contextualMessage;
            return yield this.signClient.request({
                topic: (_b = (_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) !== null && _b !== void 0 ? _b : '',
                chainId: (_c = this.getChainId()) !== null && _c !== void 0 ? _c : '',
                request,
            });
        });
    }
    constructor(client, initSession) {
        this._session = null;
        this.contextualMessage = undefined;
        this.emitter = new events_1.default();
        this.signClient = client;
        if (initSession) {
            this.session = initSession;
        }
    }
    get session() {
        return this._session;
    }
    set session(session) {
        this._session = session;
        this.emitter.emit('session', session);
    }
    static init(options, initSession) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield sign_client_1.default.init(options);
            return new WcSdk(client, initSession);
        });
    }
    isConnected() {
        return !!this.session;
    }
    getChainId() {
        const info = this.getAccountInfo();
        return info && `${info[0]}:${info[1]}`;
    }
    getAccountAddress() {
        const info = this.getAccountInfo();
        return info && info[2];
    }
    getAccountInfo() {
        var _a, _b;
        const theOnlyBlockchain = exports.SUPPORTED_BLOCKCHAINS[0];
        const accounts = (_a = this.session) === null || _a === void 0 ? void 0 : _a.namespaces[theOnlyBlockchain].accounts;
        if (!(accounts === null || accounts === void 0 ? void 0 : accounts.length)) {
            return null;
        }
        return (_b = accounts[0].split(':')) !== null && _b !== void 0 ? _b : null;
    }
    manageDisconnect() {
        this.signClient.events.removeAllListeners('session_delete');
        this.signClient.on('session_delete', () => __awaiter(this, void 0, void 0, function* () {
            this.session = null;
        }));
    }
    loadSession() {
        if (this.signClient.session.values[0]) {
            this.session = this.signClient.session.values[0];
        }
        return this.session;
    }
    manageSession() {
        return __awaiter(this, void 0, void 0, function* () {
            this.manageDisconnect();
            return this.loadSession();
        });
    }
    connect(network, methods) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (methods === undefined) {
                console.warn(defaultMethodRemovedWarning);
                methods = ['invokeFunction', 'testInvoke', 'signMessage', 'verifyMessage'];
            }
            const { uri, approval } = yield this.createConnection(network, methods);
            if (uri) {
                (_a = window.open(`https://neon.coz.io/connect?uri=${uri}`, '_blank')) === null || _a === void 0 ? void 0 : _a.focus();
            }
            this.session = yield approval();
            return this.session;
        });
    }
    createConnection(network, methods) {
        return __awaiter(this, void 0, void 0, function* () {
            if (methods === undefined) {
                console.warn(defaultMethodRemovedWarning);
                methods = ['invokeFunction', 'testInvoke', 'signMessage', 'verifyMessage'];
            }
            const { approval, uri } = yield this.signClient.connect({
                requiredNamespaces: {
                    [exports.SUPPORTED_BLOCKCHAINS[0]]: {
                        chains: [network],
                        methods,
                        events: [],
                    },
                },
            });
            const approvalWrapper = () => __awaiter(this, void 0, void 0, function* () {
                const session = yield approval();
                this.session = session;
                return session;
            });
            const uriAndWccv = `${uri}&wccv=${exports.COMPATIBILITY_VERSION}`;
            return {
                approval: approvalWrapper,
                uri: uriAndWccv,
            };
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.session)
                return;
            yield this.signClient.disconnect({
                topic: this.session.topic,
                reason: {
                    code: 5900,
                    message: 'USER_DISCONNECTED',
                },
            });
            this.session = null;
        });
    }
    signTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateContractInvocationMulti(params);
            const resp = yield this.sendRequest('signTransaction', params);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    invokeFunction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateContractInvocationMulti(params);
            const resp = yield this.sendRequest('invokeFunction', params);
            if (typeof resp !== 'string') {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    calculateFee(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateContractInvocationMulti(params);
            const resp = yield this.sendRequest('calculateFee', params);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    testInvoke(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.validateContractInvocationMulti(params);
            const resp = (yield this.sendRequest('testInvoke', params));
            if (!resp || (resp && resp.state !== 'HALT')) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    signMessage(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('signMessage', params);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    verifyMessage(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('verifyMessage', params);
            if (resp === null || resp === undefined) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    traverseIterator(sessionId, iteratorId, count) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('traverseIterator', [sessionId, iteratorId, count]);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    getWalletInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('getWalletInfo', []);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    getNetworkVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('getNetworkVersion', []);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    encrypt(message, publicKeys) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('encrypt', [message, publicKeys]);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    decrypt(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('encrypt', [payload]);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    decryptFromArray(payloads) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('decryptFromArray', [payloads]);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    wipeRequests() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.sendRequest('wipeRequests', []);
            if (!resp) {
                throw new WcSdkError(resp);
            }
            return resp;
        });
    }
    withContext(contextualMessage) {
        this.contextualMessage = contextualMessage;
        return this;
    }
    validateContractInvocationMulti(request) {
        var _a;
        this.objectValidation(request, ['signers', 'invocations']);
        (_a = request.signers) === null || _a === void 0 ? void 0 : _a.forEach((signer, i) => {
            if (signer.allowedContracts && signer.allowedContracts.length > 0 && request.signers) {
                request.signers[i].allowedContracts = signer.allowedContracts.map((scriptHash) => {
                    if (!(scriptHash.length === 42 || scriptHash.length === 40)) {
                        throw new Error(`Invalid Script Hash (allowed contract): ${scriptHash}`);
                    }
                    return scriptHash.length === 42 ? scriptHash : `0x${scriptHash}`;
                });
            }
        });
        request.invocations.forEach((invocation, i) => {
            var _a;
            this.objectValidation(invocation, ['scriptHash', 'operation', 'args']);
            if (!(invocation.scriptHash.length === 42 || invocation.scriptHash.length === 40)) {
                throw new Error(`Invalid Script Hash: ${invocation.scriptHash}`);
            }
            request.invocations[i].scriptHash =
                invocation.scriptHash.length === 42 ? invocation.scriptHash : `0x${invocation.scriptHash}`;
            (_a = invocation.args) === null || _a === void 0 ? void 0 : _a.forEach((arg) => {
                this.objectValidation(arg, ['type', 'value']);
            });
        });
        return true;
    }
    objectValidation(object, keys) {
        const objectKeys = Object.keys(object);
        keys.forEach((req) => {
            if (objectKeys.indexOf(req) < 0) {
                throw new Error(`Missing required argument field ${req} in ${req}`);
            }
        });
        return true;
    }
}
exports.WcSdk = WcSdk;
exports.default = WcSdk;
__exportStar(require("@cityofzion/neon-dappkit-types"), exports);
//# sourceMappingURL=index.js.map