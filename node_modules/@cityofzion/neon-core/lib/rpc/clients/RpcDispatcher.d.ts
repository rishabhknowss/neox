import { Query, RPCResponse, RPCErrorResponse, JsonRpcParams } from "../Query";
import { BatchQuery } from "../BatchQuery";
export interface RpcConfig {
    timeout?: number;
}
export type GConstructor<T = {}> = new (...args: any[]) => T;
export type RpcDispatcherMixin = GConstructor<RpcDispatcher>;
/**
 * Low level method to directly send a json-rpc request.
 * @param url - address to send request to
 * @param query - json-rpc request body
 * @param config - rpc configuration
 * @returns a json-rpc response
 */
export declare function sendQuery<TResponse>(url: string, query: Query<JsonRpcParams, TResponse>, config?: RpcConfig): Promise<RPCResponse<TResponse>>;
/**
 * Low level method to directly send a list of json-rpc requests.
 * Note that the responses will not be typed.
 * @param url - address to send request to
 * @param batch - array
 * @param config - rpc configuration
 * @returns a list of untyped json-rpc responses
 */
export declare function sendQueryList(url: string, batch: Query<JsonRpcParams, unknown>[], config?: RpcConfig): Promise<RPCResponse<unknown>[]>;
/**
 * Basic JSON-RPC 2.0 Dispatcher. Contains the basic infrastructure to send out JSON-RPC 2.0 methods.
 * Client interfaces should accept this RpcDispatcher as a constructor parameter.
 *
 * @example
 *
 * ```ts
 * const dispatcher = new RpcDispatcher("http://www.example.com");
 * const result = await dispatcher.execute(new Query({"method": "listplugins"}));
 * ```
 */
export declare class RpcDispatcher {
    url: string;
    constructor(url: string);
    /**
     * Takes an Query object and executes it. Throws if error is encountered.
     */
    execute<TResponse>(query: Query<JsonRpcParams, TResponse>, config?: RpcConfig): Promise<TResponse>;
    /**
     * Takes an array of Queries and executes them.
     * Throws if any of the queries encounters an error.
     * @param batchQuery - Array of queries or a BatchQuery
     * @param config - Configuration to apply to the RPC call
     * @returns list of unwrapped json-rpc results
     *
     * @example
     *
     * ```ts
     * const dispatcher = new RpcDispatcher("http://www.example.com");
     * const response = dispatcher.executeAll(
     *    BatchQuery.of(new Query({method: "getversion"}))
     *      .add(new Query({method: "getblockcount"}))
     * );
     * // Correctly typed response when using BatchQuery
     * console.log(response[0].protocol.network);
     *
     * // You will have to manually type the response when using a plain array
     * const response = dispatcher.executeAll<GetVersionResult, number>([
     *    new Query({method: "getversion"}),
     *    new Query({method: "getblockcount"})
     * ]);
     *
     * console.log(response[0].protocol.network);
     * ```
     */
    executeAll<TResponses extends unknown[]>(batchQuery: BatchQuery<JsonRpcParams[], TResponses>, config?: RpcConfig): Promise<TResponses>;
    executeAll<TResponses extends unknown[]>(batchQuery: Query<JsonRpcParams, unknown>[], config?: RpcConfig): Promise<TResponses>;
}
export declare class RpcError extends Error {
    code: number;
    constructor(errResponse: RPCErrorResponse);
}
//# sourceMappingURL=RpcDispatcher.d.ts.map