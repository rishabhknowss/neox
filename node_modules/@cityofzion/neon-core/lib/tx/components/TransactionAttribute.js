import { num2VarInt, reverseHex, base642hex, } from "../../u";
import { parseEnum } from "../../internal";
export var TransactionAttributeType;
(function (TransactionAttributeType) {
    TransactionAttributeType[TransactionAttributeType["HighPriority"] = 1] = "HighPriority";
    TransactionAttributeType[TransactionAttributeType["OracleResponse"] = 17] = "OracleResponse";
})(TransactionAttributeType || (TransactionAttributeType = {}));
export var OracleResponseCode;
(function (OracleResponseCode) {
    // Indicates that the request has been successfully completed.
    OracleResponseCode[OracleResponseCode["Success"] = 0] = "Success";
    // Indicates that the protocol of the request is not supported.
    OracleResponseCode[OracleResponseCode["ProtocolNotSupported"] = 16] = "ProtocolNotSupported";
    // Indicates that the oracle nodes cannot reach a consensus on the result of the request.
    OracleResponseCode[OracleResponseCode["ConsensusUnreachable"] = 18] = "ConsensusUnreachable";
    // Indicates that the requested Uri does not exist.
    OracleResponseCode[OracleResponseCode["NotFound"] = 20] = "NotFound";
    // Indicates that the request was not completed within the specified time.
    OracleResponseCode[OracleResponseCode["Timeout"] = 22] = "Timeout";
    // Indicates that there is no permission to request the resource.
    OracleResponseCode[OracleResponseCode["Forbidden"] = 24] = "Forbidden";
    // Indicates that the data for the response is too large.
    OracleResponseCode[OracleResponseCode["ResponseTooLarge"] = 26] = "ResponseTooLarge";
    // Indicates that the request failed due to insufficient balance.
    OracleResponseCode[OracleResponseCode["InsufficientFunds"] = 28] = "InsufficientFunds";
    // Indicates that the content-type of the request is not supported.
    OracleResponseCode[OracleResponseCode["ContentTypeNotSupported"] = 31] = "ContentTypeNotSupported";
    // Indicates that the request failed due to other errors.
    OracleResponseCode[OracleResponseCode["Error"] = 255] = "Error";
})(OracleResponseCode || (OracleResponseCode = {}));
export class TransactionAttribute {
    get size() {
        return 1;
    }
    static fromJson(input) {
        const attrType = parseEnum(input.type, TransactionAttributeType);
        const implementingClass = this.getImplementation(attrType);
        return implementingClass.fromJson(input);
    }
    static fromStream(ss) {
        return TransactionAttribute.deserialize(ss);
    }
    static deserialize(ss) {
        const rawType = parseInt(ss.peek(1), 16);
        const attrType = parseEnum(rawType, TransactionAttributeType);
        const implementingClass = this.getImplementation(attrType);
        return implementingClass.deserialize(ss);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    static getImplementation(type) {
        switch (type) {
            case TransactionAttributeType.HighPriority:
                return HighPriorityAttribute;
            case TransactionAttributeType.OracleResponse:
                return OracleResponseAttribute;
            default:
                throw new Error(`Unknown TransactionAttributeType: ${type}`);
        }
    }
    serialize() {
        return this.type.toString(16).padStart(2, "0");
    }
}
class HighPriorityAttribute extends TransactionAttribute {
    get type() {
        return HighPriorityAttribute._type;
    }
    static fromJson(_) {
        return new HighPriorityAttribute();
    }
    static deserialize(ss) {
        readAndAssertType(ss, this._type);
        return new HighPriorityAttribute();
    }
    toJson() {
        return { type: "HighPriority" };
    }
    export() {
        return {
            type: this.type,
        };
    }
}
HighPriorityAttribute._type = TransactionAttributeType.HighPriority;
export { HighPriorityAttribute };
class OracleResponseAttribute extends TransactionAttribute {
    get type() {
        return OracleResponseAttribute._type;
    }
    get size() {
        return this.serialize().length / 2;
    }
    static fromJson(input) {
        const code = parseEnum(input.code, OracleResponseCode);
        return new OracleResponseAttribute(input.id, code, input.result);
    }
    static deserialize(ss) {
        readAndAssertType(ss, this._type);
        const id = parseInt(ss.read(8), 16);
        const codeName = OracleResponseCode[parseInt(ss.read(1), 16)];
        const code = parseEnum(codeName, OracleResponseCode);
        const resultSize = ss.readVarInt();
        if (resultSize > 0xffff) {
            throw new Error(`Results size exceeds maximum`);
        }
        const result = ss.read(resultSize);
        return new OracleResponseAttribute(id, code, result);
    }
    constructor(id, code, result) {
        super();
        this.id = id;
        this.code = code;
        this.result = result;
    }
    toJson() {
        return {
            type: "OracleResponse",
            id: this.id,
            code: OracleResponseCode[this.code],
            result: this.result,
        };
    }
    serialize() {
        const id = reverseHex(this.id.toString(16).padStart(16, "0"));
        const code = this.code.toString(16).padStart(2, "0");
        const result = base642hex(this.result.toString());
        const resultLen = num2VarInt(result.length / 2);
        return super.serialize() + id + code + resultLen + result;
    }
    export() {
        return {
            type: this.type,
            id: this.id,
            code: this.code,
            result: this.result,
        };
    }
}
OracleResponseAttribute._type = TransactionAttributeType.OracleResponse;
export { OracleResponseAttribute };
function readAndAssertType(ss, type) {
    const rawType = parseInt(ss.read(1), 16);
    const txType = parseEnum(rawType, TransactionAttributeType);
    if (txType !== type) {
        throw new Error(`Wrong TransactionAttributeType. Wanted ${TransactionAttributeType[type]} but got ${txType}`);
    }
}
export default TransactionAttribute;
//# sourceMappingURL=TransactionAttribute.js.map